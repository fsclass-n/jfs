<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 함수</title>
</head>

<body>
    <!-- 버튼 클릭시 함수 호출 -->
    <button type="button" onclick="printMsg2('이기자', 30)">누르세요!</button>

    <script>
        /* 
            함수(function) 작성
                - {제어문}과 마찬가지로 {함수} 선언문 끝에도 ;를 쓰지 않는다.
                - 이름 지정 방법은 변수와 같다.

                1) 선언적 함수 선언
                    function 함수명([매개변수1, 매개변수2, ...]) {
                        코드;
                        [return 반환값;]
                    }

                    매개변수(parameter): 변수
                    인자(argument): 값

                2) 익명(무명) 함수 선언
                    const 변수명 = function (매개변수1, 매개변수2, ...) {
                        코드;
                    }

                3) 함수 호출
                    함수(변수)명([인자1, 인자2, ...]);

            함수는 왜?
                반복 코드를 재사용!

        */

        document.write('함수가 아닙니다.');
        document.write('함수가 아닙니다.');

        // 매개변수가 없는 함수
        // 자바스크립트 호이스팅은 인터프리터가 코드를 실행하기 전에 변수와 함수 선언을 해당 스코프(유효 범위)의 최상단으로 끌어올리는 것처럼 보이는 현상입니다. 이로 인해 코드에 선언된 위치보다 위에서 변수나 함수를 사용해도 오류가 발생하지 않고, 마치 선언이 먼저 된 것처럼 동작합니다. 
        fn(); // 호이스팅(Hoisting)
        // 함수 선언
        function fn() {
            document.write('함수입니다.');
        }
        // 함수 호출
        fn(); fn();

        const txt1 = '함수 선언 전 호출';
        const txt2 = '함수 선언 후 호출';
        
        printMsg(txt1); // 호이스팅

        // 함수 선언
        function printMsg(msg) {
            document.write(msg + '<br>');
        }

        // 함수 호출
        printMsg(txt2)


        // 이름이 같으면 아래 함수가 호출된다.
        function printMsg2(name, age) {
            document.write('이름은 ' + name + '이고, 나이는 '  + age + '살 입니다.<br>');
        }

        printMsg2('홍길동', 21);

    </script>
</body>

</html>